
模型分层设计：接入层模型view object，业务层Domain Model领域模型，数据层Data Object数据模型



nginx：作为--反向代理动态请求到后端，--做动静分离服务器，--静态服务器（放入静态页面html/css/js，提供静态页面的访问）
使用OpenResty来配置nginx更方便
高性能原因：基于epoll的多路复用（变更触发直接读取）--非阻塞io；master-worker进程模型（worker进程实际处理，单线程epoll）；
使用进程池和单线程(多路复用--select/epoll)模型，每个进程绑定到独立cpu上 避免了进程切换；
基于协程的非阻塞模型（依附于线程的内存模型，切换小存在于用户态，无需加锁只有遇到阻塞才会切换到其他协程--遇到阻塞会注册到epoll事件模型，
对于线程来说是同步调用的编程简单，实现=使用resume--获得cpu执行权和yield--放弃cpu执行权来实现，Python中的yied和next/send）；



分布式服务架构：nginx单独处理静态请求服务器，秒杀服务器两台处理动态请求服务器，mysql+redis为一台服务器处理请求
ps：全部部署在一台主机tps（每秒处理的事务请求量）为150左右，分布式架构之后tps为1500左右。



分布式会话：基于cookie传输sessionid但有些app端会禁用cookie（直接引入依赖spring实现的和springboot整合的，激活redis客户端即可），
传输sessionid到前端页面使用localStorage进行存储（将sessionid和session存储到redis即可，在前端就可以进行判断token是否登陆），；
共同点--他们都需要session进行集中式管理，基于token的localstore是永不失效的需要js进行控制。




redis缓存：哨兵模式（监测主从节点进行故障转移，且不存储数据，数据如果需要分片就要在维护一对主从节点），集群cluster模式（多主多从）
对商品详情进行缓存,key序列化为string对象，value序列化为json字符串
加入redis缓存tps可以达到2000左右



本地热点缓存：热点数据，脏读不敏感，内存可控（生命周期短）类似lru，可以设置1分钟内没有写操作就删除掉，
可以保证缓存失效导致并发写时让一个线程阻塞去更新值其他线程遇到阻塞返回原值，处理缓存击穿问题。
对于tps提升特别大从2000左右可以到达3000左右。



nginx缓存：nginx proxy cache将请求对应一个文件，然后来进行建立索引获取缓存，因为读取的是nginx的文件没在内存中所以不如本地缓存快（直接配置）
openresty(某宝基于Nginx进行开发增强，把lua嵌入进去让nginx进行实时配置更新)使用shared dict共享字典，lru淘汰，只是少一次rpc调用缓存更新机制不好，tps性能跟tomcat内存差不多（编写lua脚本）
openresty使用redis进行缓存，只读不写解决数据不一致，可减少一次到tomcat服务器的rpc调用（编写lua脚本）
最终：性能与本地热点缓存相差不多，推荐使用nginx做redis的只读缓存+tomcat服务器java的本地缓存+tomcat服务器的redis缓存；



cdn缓存静态页面：阿里云创建cdn，创建一个加速域名先与nginx服务器匹配获得一个cname地址，在添加已经购买域名的解析规则将购买的域名和
加速域名以及cname地址也就是阿里云服务器进行匹配。
private--客户端可以缓存，public--客户端和服务端都可以缓存，max-age--缓存的内存在xxx秒后失效，no-store--不缓存内容
no-cache--返回缓存时，需要向服务器验证是否过期



交易性能瓶颈：
1.悲观锁实现的下单和减库存在一个事务中，tps500多，平均耗时大概0.6秒（没有利用乐观锁，因为他最终在减库存上还是会加锁的，
需要先查出来在这个阶段不加锁，减库存比对版本号时会加锁）
2.活动发布同步库存进redis缓存，下单时减缓存的数据库存，会有数据库数据不一致情况保证最终一致性即可--选择异步消息扣减数据库内的库存
rocketmq不需要强一致性，只需要数据库里库存的最终一致性即可。
redis和mq的事务需要自己维护，先减库存如果redis减成功并且下单成功，最后在进行发送消息去myslq扣库存，基于此可以保证事务。
当库存售完时，给redis设立一个标识位，然后再次下单的时候进行判断如果存在该标示则更新商品详情的缓存，并且提示下单失败。
tps大概800多，平均耗时差不多



流量削峰：没超过预估流量时，应对突发流量
1.活动未开始脚本刷接口: （防止接口在活动未开始就被刷单）使用秒杀令牌，当秒杀开始之后才可以设置令牌进缓存并且进行发放令牌，
先访问生成令牌接口持有令牌之后，才可以进行下单。
ps：如果秒杀开始，脚本刷接口，可以通过前端加密参数进行保护。账号风控监测等分类模型
2.秒杀大闸：根据库存量，设置令牌的总数量（5倍即可），再发布活动信息的时候设置
秒杀令牌和秒杀大闸，在多库存，多商品情况下限制能力弱；
3.队列泄洪：用户下单过程中使用拥塞窗口为20的队列--使用java的线程池；


流量限流：预估流量往往会出现意外
令牌桶算法：
漏桶算法：

----------------------------------------------------------------------------------------------------------------







